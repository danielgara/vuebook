- Mixins: Cuando una función se repite en diferentes archivos VUE, entonces una buena opción seria crear un mixin.
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/views/ProjectModels.vue -> export default class ProjectModels extends mixins(GlobalVueFunctions)

- Decorators: Cuando necesitamos modificar el comportamiento de un método o ejecutar algunas funcionalidades antes de la ejecución de ese método, entonces una opción es definir un Decorator. Por ejemplo ejecutar algo antes del mounted()

- Hook: Cuando necesitamos modificar un componente, antes, durante, o después de alguna acción del ciclo de vida de los componentes, entonces usamos un Hook.
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/views/ProjectModels.vue -> beforeMount

- vue-class-component: útil para dar estructura de clases a los archivos vue.
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/views/ProjectModels.vue 

- vue-property-decorator: útil para definir otros decoradores que no trae vue-class-component como watch, prop, etc.

- Plugins: útiles para definir componentes globales, que queremos utilizar dentro de muchos otros componentes.
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/plugins/ModalPlugin.ts

- emits: sirve para indicar que el componente emitira un evento. Ejemplo emits: ['add-task'] (en el component hijo).

- @add-task (v-on:add-task): forma de recibir un evento de un hijo.

- components: sirve para declarar los componentes que serán utilizados dentro del component actual.
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/views/Docs.vue

- watch $route: para definir acciones cuando se cambian las rutas.
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/views/ProjectModels.vue -> watch

- props: sirve para recibir datos del componente padre.
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/components/Breadcrumb.vue -> props

- computed properties: https://es.vuejs.org/v2/guide/computed.html

Interesante, diferencia entre propiedad computada y método normal:
En lugar de una propiedad computada, podemos definir la misma función como un método en su lugar. Para el resultado final, los dos enfoques son exactamente los mismos. Sin embargo, la diferencia es que las propiedades computadas se almacenan en caché según sus dependencias. Una propiedad computada solo se volverá a evaluar cuando alguna de sus dependencias haya cambiado. Esto significa que mientras message no haya cambiado, el acceso múltiple a la propiedad computada de reverseMessage regresará inmediatamente el resultado previamente calculado sin tener que ejecutar la función de nuevo.

Ejemplo en vue-class-component style:

public firstName:string = "Daniel";
public lastName:string = "Correa";

public get name(){ //computed property in vue-class-style
  return this.firstName + " " + this.lastName;
}

- vuelidate (npm install vuelidate) para validaciones, y con TypeScript se necesita (npm install @types/vuelidate)
- vuelidate for Vue 3.0 requires (npm install @vuelidate/core @vuelidate/validators)

- slots: espacios en blanco, o zonas que se pueden reemplazar por componentes, HTML o lo que sea.

- functional components: componentes que son stateless, que no almacenan datos, utiles para rendizar pedazos de vistas o donde no se necesiten datos.
- en vue 3.0 ya no existen functional components. Mas info aquí: https://v3.vuejs.org/guide/migration/functional-components.html#overview

- $refs: colocar referencia a componentes hijos para acceder a los datos de ellos.

- $parent: utilizado en un componente hijo para acceder a los datos del padre.

- $root: utilizado en un componente para acceder a los datos del component raíz de vue (generalmente App).
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/views/ProjectModels.vue -> implementSearchBarFunction()

- etiqueta <component> se usa para definir componentes dinamicos. Que se cargan de acuerdo alguna variable o método vue.
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/views/ProjectModels.vue -> <component :is="customComponentModelActions" :variaMosGraph="variaMosGraph" />

- provide/inject: para inyección de dependencias. Mas info: https://v3.vuejs.org/guide/component-provide-inject.html
In fact, you can think of dependency injection as sort of “long-range props”, except:
* parent components don’t need to know which descendants use the properties it provides
* child components don’t need to know where injected properties are coming from
OJO no es reactivo. Si se cambia un dato en el padre, no se cambia en el hijo. Toca hacer cambios con ref, para que sea reactivo.

- Lazy loading: cargar componentes cuando sea necesario. Esto gracias a webpack.
- defineAsyncComponent. Metodo para lazy loading.
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/views/ProjectModels.vue ->  loadCustomComponentModelActions()

- miragejs: simular un pequeño server http con JSON

- axios: libreria top reina del protocolo http
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/assets/js/custom_models/component/custom/ComponentDerivation.vue -> public testComponentBackend()

- vue-router: sirve para administrar las rutas de la aplicación
EJEMPLO:  https://github.com/danielgara/VariaMos/blob/main/src/router/index.ts

- alias (router): An alias of /a as /b means when the user visits /b, the URL remains /b, but it will be matched as if the user is visiting /a.

- redirect (router). Example: /home redirects to / (name can be also used)

  {
    path: '/home',
    name: 'home',
    redirect: '/',
  }

- nested routes (router). Incluir un atributo children en la ruta padre, con la información de la ruta hija.

- 404 page: incluir un path en el archivo de rutas con una regex.
EJEMPLO: https://github.com/danielgara/VariaMos/blob/main/src/router/index.ts -> path: '/:pathMatch(.*)*'

